{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useMulticallContract } from '../../hooks/useContract';\nimport useDebounce from '../../hooks/useDebounce';\nimport chunkArray from '../../utils/chunkArray';\nimport { retry, RetryableError } from '../../utils/retry';\nimport { useBlockNumber } from '../application/hooks';\nimport { errorFetchingMulticallResults, fetchingMulticallResults, parseCallKey, updateMulticallResults } from './actions'; // chunk calls so we do not exceed the gas limit\n\nconst CALL_CHUNK_SIZE = 500;\nlet datahin;\n/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\n\nasync function fetchChunk(multicallContract, chunk, minBlockNumber) {\n  let resultsBlockNumber;\n  let returnData;\n\n  try {\n    [resultsBlockNumber, returnData] = await multicallContract.aggregate(chunk.map(obj => [obj.address, obj.callData]));\n  } catch (error) {\n    console.info('Failed to fetch chunk inside retry', error);\n    throw error;\n  }\n\n  datahin = returnData; // eslint-disable-next-line no-console\n\n  console.log(datahin);\n\n  if (resultsBlockNumber.toNumber() < minBlockNumber) {\n    throw new RetryableError('Fetched for old block number');\n  }\n\n  return {\n    results: datahin,\n    blockNumber: resultsBlockNumber.toNumber()\n  };\n}\n/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\n\n\nexport function activeListeningKeys(allListeners, chainId) {\n  if (!allListeners || !chainId) return {};\n  const listeners = allListeners[chainId];\n  if (!listeners) return {};\n  return Object.keys(listeners).reduce((memo, callKey) => {\n    const keyListeners = listeners[callKey];\n    memo[callKey] = Object.keys(keyListeners).filter(key => {\n      const blocksPerFetch = parseInt(key);\n      if (blocksPerFetch <= 0) return false;\n      return keyListeners[blocksPerFetch] > 0;\n    }).reduce((previousMin, current) => {\n      return Math.min(previousMin, parseInt(current));\n    }, Infinity);\n    return memo;\n  }, {});\n}\n/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\n\nexport function outdatedListeningKeys(callResults, listeningKeys, chainId, latestBlockNumber) {\n  if (!chainId || !latestBlockNumber) return [];\n  const results = callResults[chainId]; // no results at all, load everything\n\n  if (!results) return Object.keys(listeningKeys);\n  return Object.keys(listeningKeys).filter(callKey => {\n    const blocksPerFetch = listeningKeys[callKey];\n    const data = callResults[chainId][callKey]; // no data, must fetch\n\n    if (!data) return true;\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1); // already fetching it for a recent enough block, don't refetch it\n\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false; // if data is older than minDataBlockNumber, fetch it\n\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber;\n  });\n}\nexport default function Updater() {\n  _s();\n\n  const dispatch = useDispatch();\n  const state = useSelector(s => s.multicall); // wait for listeners to settle before triggering updates\n\n  const debouncedListeners = useDebounce(state.callListeners, 100);\n  const latestBlockNumber = useBlockNumber();\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const multicallContract = useMulticallContract();\n  const cancellations = useRef();\n  const listeningKeys = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, chainId);\n  }, [debouncedListeners, chainId]);\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber);\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber]);\n  const serializedOutdatedCallKeys = useMemo(() => JSON.stringify(unserializedOutdatedCallKeys.sort()), [unserializedOutdatedCallKeys]);\n  useEffect(() => {\n    var _cancellations$curren, _cancellations$curren2, _cancellations$curren5;\n\n    if (!latestBlockNumber || !chainId || !multicallContract) return;\n    const outdatedCallKeys = JSON.parse(serializedOutdatedCallKeys); // eslint-disable-next-line no-console\n\n    console.log(outdatedCallKeys);\n    if (outdatedCallKeys.length === 0) return;\n    const calls = outdatedCallKeys.map(key => parseCallKey(key)); // .filter(item => item.address.toLowerCase() !== '0x5Fe5cC0122403f06abE2A75DBba1860Edb762985'.toLowerCase())\n\n    const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE); // eslint-disable-next-line no-console\n\n    console.log((_cancellations$curren = cancellations.current) === null || _cancellations$curren === void 0 ? void 0 : _cancellations$curren.blockNumber); // eslint-disable-next-line no-console\n\n    console.log(latestBlockNumber);\n\n    if (((_cancellations$curren2 = cancellations.current) === null || _cancellations$curren2 === void 0 ? void 0 : _cancellations$curren2.blockNumber) !== latestBlockNumber) {\n      var _cancellations$curren3, _cancellations$curren4;\n\n      (_cancellations$curren3 = cancellations.current) === null || _cancellations$curren3 === void 0 ? void 0 : (_cancellations$curren4 = _cancellations$curren3.cancellations) === null || _cancellations$curren4 === void 0 ? void 0 : _cancellations$curren4.forEach(c => c());\n    } // eslint-disable-next-line no-console\n\n\n    console.log(\"then\"); // eslint-disable-next-line no-console\n\n    console.log((_cancellations$curren5 = cancellations.current) === null || _cancellations$curren5 === void 0 ? void 0 : _cancellations$curren5.blockNumber); // eslint-disable-next-line no-console\n\n    console.log(latestBlockNumber);\n    dispatch(fetchingMulticallResults({\n      calls,\n      chainId,\n      fetchingBlockNumber: latestBlockNumber\n    }));\n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        const {\n          cancel,\n          promise\n        } = retry(() => fetchChunk(multicallContract, chunk, latestBlockNumber), {\n          n: Infinity,\n          minWait: 2500,\n          maxWait: 3500\n        });\n        promise.then(({\n          results: datahin,\n          blockNumber: fetchBlockNumber\n        }) => {\n          cancellations.current = {\n            cancellations: [],\n            blockNumber: latestBlockNumber\n          };\n          const returnData = datahin; // accumulates the length of all previous indices\n\n          const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce((memo, curr) => memo + curr.length, 0);\n          const lastCallKeyIndex = firstCallKeyIndex + datahin.length; // eslint-disable-next-line no-console\n\n          dispatch(updateMulticallResults({\n            chainId,\n            results: outdatedCallKeys.slice(firstCallKeyIndex, lastCallKeyIndex).reduce((memo, callKey, i) => {\n              var _datahin$i;\n\n              memo[callKey] = (_datahin$i = datahin[i]) !== null && _datahin$i !== void 0 ? _datahin$i : null;\n              return memo;\n            }, {}),\n            blockNumber: fetchBlockNumber\n          }));\n        }).catch(({\n          results: returnData,\n          blockNumber: fetchBlockNumber\n        }) => {\n          // eslint-disable-next-line no-console\n          // console.log(error)\n          returnData = datahin; // if (error instanceof CancelledError) {\n          //   console.error('Cancelled fetch for blockNumber', latestBlockNumber)\n          //   return\n          // } cancellations.current = { cancellations: [], blockNumber: latestBlockNumber }\n          // accumulates the length of all previous indices\n\n          const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce((memo, curr) => memo + curr.length, 0);\n          const lastCallKeyIndex = firstCallKeyIndex + datahin.length; // eslint-disable-next-line no-console\n\n          dispatch(updateMulticallResults({\n            chainId,\n            results: outdatedCallKeys.slice(firstCallKeyIndex, lastCallKeyIndex).reduce((memo, callKey, i) => {\n              var _datahin$i2;\n\n              memo[callKey] = (_datahin$i2 = datahin[i]) !== null && _datahin$i2 !== void 0 ? _datahin$i2 : null;\n              return memo;\n            }, {}),\n            blockNumber: fetchBlockNumber\n          }));\n          console.error('Failed to fetch multicall chunk', chunk, chainId);\n          dispatch(errorFetchingMulticallResults({\n            calls: chunk,\n            chainId,\n            fetchingBlockNumber: latestBlockNumber\n          }));\n        });\n        return cancel;\n      })\n    };\n  }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber]);\n  return null;\n}\n\n_s(Updater, \"xpRD+AhDwmTdNwtyGSlpafZt7S0=\", false, function () {\n  return [useDispatch, useSelector, useDebounce, useBlockNumber, useActiveWeb3React, useMulticallContract];\n});\n\n_c = Updater;\n\nvar _c;\n\n$RefreshReg$(_c, \"Updater\");","map":{"version":3,"sources":["/Users/smb/ZkSyncSwap/pancake-swap-interface-v1/src/state/multicall/updater.tsx"],"names":["useEffect","useMemo","useRef","useDispatch","useSelector","useActiveWeb3React","useMulticallContract","useDebounce","chunkArray","retry","RetryableError","useBlockNumber","errorFetchingMulticallResults","fetchingMulticallResults","parseCallKey","updateMulticallResults","CALL_CHUNK_SIZE","datahin","fetchChunk","multicallContract","chunk","minBlockNumber","resultsBlockNumber","returnData","aggregate","map","obj","address","callData","error","console","info","log","toNumber","results","blockNumber","activeListeningKeys","allListeners","chainId","listeners","Object","keys","reduce","memo","callKey","keyListeners","filter","key","blocksPerFetch","parseInt","previousMin","current","Math","min","Infinity","outdatedListeningKeys","callResults","listeningKeys","latestBlockNumber","data","minDataBlockNumber","fetchingBlockNumber","Updater","dispatch","state","s","multicall","debouncedListeners","callListeners","cancellations","unserializedOutdatedCallKeys","serializedOutdatedCallKeys","JSON","stringify","sort","outdatedCallKeys","parse","length","calls","chunkedCalls","forEach","c","index","cancel","promise","n","minWait","maxWait","then","fetchBlockNumber","firstCallKeyIndex","slice","curr","lastCallKeyIndex","i","catch"],"mappings":"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","sourcesContent":["import { Contract } from '@ethersproject/contracts'\nimport { useEffect, useMemo, useRef } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { useActiveWeb3React } from '../../hooks'\nimport { useMulticallContract } from '../../hooks/useContract'\nimport useDebounce from '../../hooks/useDebounce'\nimport chunkArray from '../../utils/chunkArray'\nimport { CancelledError, retry, RetryableError } from '../../utils/retry'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  Call,\n  errorFetchingMulticallResults,\n  fetchingMulticallResults,\n  parseCallKey,\n  updateMulticallResults,\n} from './actions'\n\n// chunk calls so we do not exceed the gas limit\nconst CALL_CHUNK_SIZE = 500\nlet datahin\n/**\n * Fetches a chunk of calls, enforcing a minimum block number constraint\n * @param multicallContract multicall contract to fetch against\n * @param chunk chunk of calls to make\n * @param minBlockNumber minimum block number of the result set\n */\nasync function fetchChunk(\n  multicallContract: Contract,\n  chunk: Call[],\n  minBlockNumber: number\n): Promise<{ results: string[]; blockNumber: number }> {\n  let resultsBlockNumber\n  let returnData\n  try {\n    [resultsBlockNumber, returnData] = await multicallContract.aggregate(\n      chunk.map((obj) => [obj.address, obj.callData])\n    )\n\n  } catch (error) {\n    console.info('Failed to fetch chunk inside retry', error)\n    throw error\n  }\n  datahin = returnData\n  // eslint-disable-next-line no-console\n  console.log(datahin)\n  if (resultsBlockNumber.toNumber() < minBlockNumber) {\n    throw new RetryableError('Fetched for old block number')\n  }\n  return { results: datahin, blockNumber: resultsBlockNumber.toNumber() }\n}\n\n/**\n * From the current all listeners state, return each call key mapped to the\n * minimum number of blocks per fetch. This is how often each key must be fetched.\n * @param allListeners the all listeners state\n * @param chainId the current chain id\n */\nexport function activeListeningKeys(\n  allListeners: AppState['multicall']['callListeners'],\n  chainId?: number\n): { [callKey: string]: number } {\n  if (!allListeners || !chainId) return {}\n  const listeners = allListeners[chainId]\n  if (!listeners) return {}\n\n  return Object.keys(listeners).reduce<{ [callKey: string]: number }>((memo, callKey) => {\n    const keyListeners = listeners[callKey]\n\n    memo[callKey] = Object.keys(keyListeners)\n      .filter((key) => {\n        const blocksPerFetch = parseInt(key)\n        if (blocksPerFetch <= 0) return false\n        return keyListeners[blocksPerFetch] > 0\n      })\n      .reduce((previousMin, current) => {\n        return Math.min(previousMin, parseInt(current))\n      }, Infinity)\n    return memo\n  }, {})\n}\n\n/**\n * Return the keys that need to be refetched\n * @param callResults current call result state\n * @param listeningKeys each call key mapped to how old the data can be in blocks\n * @param chainId the current chain id\n * @param latestBlockNumber the latest block number\n */\nexport function outdatedListeningKeys(\n  callResults: AppState['multicall']['callResults'],\n  listeningKeys: { [callKey: string]: number },\n  chainId: number | undefined,\n  latestBlockNumber: number | undefined\n): string[] {\n  if (!chainId || !latestBlockNumber) return []\n  const results = callResults[chainId]\n  // no results at all, load everything\n  if (!results) return Object.keys(listeningKeys)\n\n  return Object.keys(listeningKeys).filter((callKey) => {\n    const blocksPerFetch = listeningKeys[callKey]\n\n    const data = callResults[chainId][callKey]\n    // no data, must fetch\n    if (!data) return true\n\n    const minDataBlockNumber = latestBlockNumber - (blocksPerFetch - 1)\n\n    // already fetching it for a recent enough block, don't refetch it\n    if (data.fetchingBlockNumber && data.fetchingBlockNumber >= minDataBlockNumber) return false\n\n    // if data is older than minDataBlockNumber, fetch it\n    return !data.blockNumber || data.blockNumber < minDataBlockNumber\n  })\n}\n\nexport default function Updater(): null {\n  const dispatch = useDispatch<AppDispatch>()\n  const state = useSelector<AppState, AppState['multicall']>((s) => s.multicall)\n  // wait for listeners to settle before triggering updates\n  const debouncedListeners = useDebounce(state.callListeners, 100)\n  const latestBlockNumber = useBlockNumber()\n  const { chainId } = useActiveWeb3React()\n  const multicallContract = useMulticallContract()\n  const cancellations = useRef<{ blockNumber: number; cancellations: (() => void)[] }>()\n\n  const listeningKeys: { [callKey: string]: number } = useMemo(() => {\n    return activeListeningKeys(debouncedListeners, chainId)\n  }, [debouncedListeners, chainId])\n\n  const unserializedOutdatedCallKeys = useMemo(() => {\n    return outdatedListeningKeys(state.callResults, listeningKeys, chainId, latestBlockNumber)\n  }, [chainId, state.callResults, listeningKeys, latestBlockNumber])\n\n  const serializedOutdatedCallKeys = useMemo(() => JSON.stringify(unserializedOutdatedCallKeys.sort()), [\n    unserializedOutdatedCallKeys,\n  ])\n\n  useEffect(() => {\n    if (!latestBlockNumber || !chainId || !multicallContract) return\n\n    const outdatedCallKeys: string[] = JSON.parse(serializedOutdatedCallKeys)\n    // eslint-disable-next-line no-console\n    console.log(outdatedCallKeys)\n    if (outdatedCallKeys.length === 0) return\n    const calls = outdatedCallKeys.map((key) => parseCallKey(key))\n    // .filter(item => item.address.toLowerCase() !== '0x5Fe5cC0122403f06abE2A75DBba1860Edb762985'.toLowerCase())\n\n    const chunkedCalls = chunkArray(calls, CALL_CHUNK_SIZE)\n    // eslint-disable-next-line no-console\n    console.log(cancellations.current?.blockNumber)\n        // eslint-disable-next-line no-console\n    console.log(latestBlockNumber)\n    \n    if (cancellations.current?.blockNumber !== latestBlockNumber) {\n      cancellations.current?.cancellations?.forEach((c) => c())\n    }\n    // eslint-disable-next-line no-console\n    console.log(\"then\")\n    // eslint-disable-next-line no-console\n    console.log(cancellations.current?.blockNumber)\n        // eslint-disable-next-line no-console\n    console.log(latestBlockNumber)\n    dispatch(\n      fetchingMulticallResults({\n        calls,\n        chainId,\n        fetchingBlockNumber: latestBlockNumber,\n      })\n    )\n    \n    cancellations.current = {\n      blockNumber: latestBlockNumber,\n      cancellations: chunkedCalls.map((chunk, index) => {\n        const { cancel, promise } = retry(() => fetchChunk(multicallContract, chunk, latestBlockNumber), {\n          n: Infinity,\n          minWait: 2500,\n          maxWait: 3500,\n        })\n        promise\n          .then(({ results: datahin, blockNumber: fetchBlockNumber }) => {\n            cancellations.current = { cancellations: [], blockNumber: latestBlockNumber }\n           const returnData = datahin\n            // accumulates the length of all previous indices\n            const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce<number>((memo, curr) => memo + curr.length, 0)\n            const lastCallKeyIndex = firstCallKeyIndex + datahin.length\n            // eslint-disable-next-line no-console\n\n            dispatch(\n              updateMulticallResults({\n                chainId,\n                results: outdatedCallKeys\n                  .slice(firstCallKeyIndex, lastCallKeyIndex)\n                  .reduce<{ [callKey: string]: string | null }>((memo, callKey, i) => {\n                    memo[callKey] = datahin[i] ?? null\n                    return memo\n                  }, {}),\n                blockNumber: fetchBlockNumber,\n              })\n            )\n          })\n          .catch(({ results: returnData, blockNumber: fetchBlockNumber }) => {\n            // eslint-disable-next-line no-console\n            // console.log(error)\n            returnData = datahin\n            // if (error instanceof CancelledError) {\n            //   console.error('Cancelled fetch for blockNumber', latestBlockNumber)\n            //   return\n            // } cancellations.current = { cancellations: [], blockNumber: latestBlockNumber }\n\n            // accumulates the length of all previous indices\n            const firstCallKeyIndex = chunkedCalls.slice(0, index).reduce<number>((memo, curr) => memo + curr.length, 0)\n            const lastCallKeyIndex = firstCallKeyIndex + datahin.length\n            // eslint-disable-next-line no-console\n            dispatch(\n              updateMulticallResults({\n                chainId,\n                results: outdatedCallKeys\n                  .slice(firstCallKeyIndex, lastCallKeyIndex)\n                  .reduce<{ [callKey: string]: string | null }>((memo, callKey, i) => {\n                    memo[callKey] = datahin[i] ?? null\n                    return memo\n                  }, {}),\n                blockNumber: fetchBlockNumber,\n              })\n            )\n            console.error('Failed to fetch multicall chunk', chunk, chainId)\n            dispatch(\n              errorFetchingMulticallResults({\n                calls: chunk,\n                chainId,\n                fetchingBlockNumber: latestBlockNumber,\n              })\n            )\n          })\n        return cancel\n      }),\n    }\n  }, [chainId, multicallContract, dispatch, serializedOutdatedCallKeys, latestBlockNumber])\n\n  return null\n}\n"]},"metadata":{},"sourceType":"module"}